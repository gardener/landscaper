# Aggregated Blueprints

The goal of this tutorial is to combine the previously created blueprints and deploy them together.

__Prerequisites__:
- Helm commandline tool (see https://helm.sh/docs/intro/install/)
- OCI compatible oci registry (e.g. GCR or Harbor)
- Kubernetes Cluster (better use two different clusters: one for the landscaper and one for the installation)
- [simple blueprint tutorial](01-create-simple-blueprint.md)
- [import blueprint tutorial](03-simple-import.md)

:warning: note that the repository `eu.gcr.io/gardener-project/landscaper/tutorials` is an example repository 
and has to be replaced with your own registry if you want to upload your own artifacts.
Although the artifacts are public readable so they can be used out-of-the-box without a need for your own oci registry.


### Resources

#### Build the aggregated blueprint

Aggregated blueprints allows developers to use blueprints and combine them to a single installation.
This feature enables the reuse of components as well as the delivery of applications that consists of multiple services.
It is also useful to build opinionated applications with recommended or enforced defaults that are necessary in a specific context.

In this tutorial, the nginx ingress and the echo server are combined to one application and bundled to one blueprint.

First the imports and exports of the aggregated blueprint have to be defined.
Therefore, the imports of the containing blueprints have to be satisfied.

The `nginx ingess blueprint` import a target of type cluster and the namespace of type `string`.
The `echo server blueprint` also imports a cluster and a namespace as well as a ingressClass.
As the ingressClass of the echo server is generated by the `nginx ingess blueprint`, only the cluster and the namespace is needed.

To give other component the ability to also use the ingress, the ingressClass is exported as well.

```yaml
apiVersion: landscaper.gardener.cloud/v1alpha1
kind: Blueprint

imports:
- name: aggCluster
  type: target
  targetType: landscaper.gardener.cloud/kubernetes-cluster
- name: aggNamespace
  type: data
  schema:
    type: string

exports:
- name: aggIngressClass
  type: data
  schema:
    type: string
```

Blueprints can be included into another blueprint by specifying them as subinstallations.
Only the raw blueprint reference is not enough as the two blueprints have to be connected the same way as it has been done in the second tutorial.

Therefore, the blueprints are included as `InstallationTemplates` that are then automatically translated into 
installations in the context of the aggregation.

For detailed documentation of InstallationTemplates see [docs/usage/Blueprints.md#installation-templates](/docs/usage/Blueprints.md#installation-templates).

In the current example, 2 subinstallations are created.

The first subinstallation defines the ingress that is installed using the previously created blueprint.
The ingress installation imports the same target cluster and namespace that is also imported by aggregated blueprint.<br>
This target and namespace import is only accessible by the subinstallation because it is imported by its parent.
Otherwise, this would not be possible.
```yaml
imports:
    targets:
    - name: cluster
      target: aggCluster # import from the aggregated blueprint.
    data:
    - name: namespace
      dataRef: aggNamespace # import from the aggregated blueprint.
```

It exports the ingressClass to the contextified data object with the name `myIngressClass`.
Contextified dtaobject means that this dataobject is only accessible by subinstallation with the same parent.
```yaml
exports:
    data:
    - name: ingressClass
      dataRef: myIngressClass # dataobject "myIngressClass" that is availabel in the context of the aggregation.
```

The second subinstallation defines the echo server that imports the ingressClass.
The ingressClass is exported by the ingress subinstallation as `myIngressClass`, so the echo has to import it with this name.

```yaml
imports:
    targets:
    - name: cluster
      target: aggCluster
    data:
    - name: namespace
      dataRef: aggNamespace # import from the aggregated blueprint.
    - name: ingressClass
      dataRef: myIngressClass
```

```yaml
subinstallations:
- apiVersion: landscaper.gardener.cloud/v1alpha1
  kind: InstallationTemplate

  name: ingress

  blueprint:
    ref: cd://componentReferences/ingress/resources/ingress-nginx-blueprint

  imports:
    targets:
    - name: cluster
      target: aggCluster
    data:
    - name: namespace
      dataRef: aggNamespace

  exports:
    data:
    - name: ingressClass
      dataRef: myIngressClass

- apiVersion: landscaper.gardener.cloud/v1alpha1
  kind: InstallationTemplate

  name: server

  blueprint:
    ref: cd://componentReferences/server/resources/echo-server-blueprint

  imports:
    targets:
    - name: cluster
      target: aggCluster
    data:
    data:
    - name: namespace
      dataRef: aggNamespace
    - name: ingressClass
      dataRef: myIngressClass
```

The last part of the aggregated blueprint is the export.
The aggregated exports the ingressClass that was created by the ingress subinstallation.
To make it consumable to other components, the `myIngressClass` dataobject is exported as `aggIngressClass`.

```yaml
exportExecutions:
- name: export
  type: GoTemplate
  template: |
    exports:
      aggIngressClass: {{ .values.dataobjects.myIngressClass }}
```

*Complete Blueprint*
```yaml
apiVersion: landscaper.gardener.cloud/v1alpha1
kind: Blueprint

imports:
- name: aggCluster
  type: target
  targetType: landscaper.gardener.cloud/kubernetes-cluster
- name: aggNamespace
  type: data
  schema:
    type: string

exports:
- name: aggIngressClass
  type: data
  schema:
    type: string

exportExecutions:
- name: export
  type: GoTemplate
  template: |
    exports:
      aggIngressClass: {{ .values.dataobjects.myIngressClass }}

subinstallations:
- apiVersion: landscaper.gardener.cloud/v1alpha1
  kind: InstallationTemplate

  name: ingress

  blueprint:
    ref: cd://componentReferences/ingress/resources/ingress-nginx-blueprint

  imports:
    targets:
    - name: cluster
      target: aggCluster
    data:
    - name: namespace
      dataRef: aggNamespace

  exports:
    data:
    - name: ingressClass
      dataRef: myIngressClass

- apiVersion: landscaper.gardener.cloud/v1alpha1
  kind: InstallationTemplate

  name: server

  blueprint:
    ref: cd://componentReferences/server/resources/echo-server-blueprint

  imports:
    targets:
    - name: cluster
      target: aggCluster
    data:
    - name: namespace
      dataRef: aggNamespace
    - name: ingressClass
      dataRef: myIngressClass
```

Upload the blueprint artifact to the registry:
```shell script
landscaper-cli blueprints push eu.gcr.io/gardener-project/landscaper/tutorials/blueprints/simple-aggregated:v0.2.0 docs/tutorials/resources/aggregated/blueprint
```

#### Create the ComponentDescriptor

The component descriptor of the aggregated blueprint is basically the same as for the other blueprints.

The only difference is that the blueprint uses these other blueprints.
Therefore, these blueprints have to be defined as dependency of the blueprint, so they can be used.

A dependency to another component descriptor is described by using the `componentReferences` where 
a reference to `github.com/gardener/landscaper/ingress-nginx` and `github.com/gardener/landscaper/echo-server` with a specific version is defined.

```yaml
meta:
  schemaVersion: v2

component:
  name: github.com/gardener/landscaper/simple-aggregated
  version: v0.2.0

  provider: internal

  repositoryContexts:
  - type: ociRegistry
    baseUrl: eu.gcr.io/gardener-project/landscaper/tutorials/components

  resources:
  - type: blueprint
    name: simple-aggregated
    relation: local
    access:
      type: ociRegistry
      imageReference: eu.gcr.io/gardener-project/landscaper/tutorials/blueprints/simple-aggregated:v0.2.0

  componentReferences:
  - name: ingress
    componentName: github.com/gardener/landscaper/ingress-nginx
    version: v0.3.0
  - name: server
    componentName: github.com/gardener/landscaper/echo-server
    version: v0.2.0
```

```shell script
landscaper-cli components-cli ca remote push docs/tutorials/resources/aggregated
```

### Installation

A Installation for the aggregated component has to be created to deploy the ingress and the echo server to the target cluster.

The installation looks similar to the nginx-ingress installation of the first tutorial.
The blueprint references and the import and exports names have to be adjusted and then the installation can be applied to the cluster.

An import for the echo-sever is not needed as its ingressClass import will be satisfied by the included nginx-ingress component.

:warning: make sure that the target `my-cluster` and the configmap `my-imports` is applied.

```yaml
apiVersion: landscaper.gardener.cloud/v1alpha1
kind: Installation
metadata:
  name: my-aggregation
spec:
  componentDescriptor:
    ref:
      repositoryContext:
        type: ociRegistry
        baseUrl: eu.gcr.io/my-project/comp
      componentName: github.com/gardener/landscaper/simple-aggregated
      version: v0.2.0

  blueprint:
    ref:
      resourceName: simple-aggregated

  imports:
    targets:
    - name: aggCluster
      # the "#" forces the landscaper to use the target with the name "my-cluster" in the same namespace
      target: "#my-cluster"
    data:
    - name: aggNamespace
      configMapRef:
        key: "namespace"
        name: "my-imports" # name of the configmap;

  exports:
    data:
    - name: aggIngressClass
      dataRef: "myAggIngressClass"
```

When a kubernetes cluster target is created and the installation is applied, the landscaper will start to install the blueprint.

The landscaper will automatically create 2 additional installation for the subinstallation.
```shell script
kubectl get inst
NAME             PHASE       CONFIGGEN   EXECUTION       AGE
ingress-jjffc    Succeeded               ingress-jjffc   3h58m
my-aggregation   Succeeded                               5h6m
server-nl5gk     Succeeded               server-nl5gk    3h58m
```

When the installation successfully finished, also all created dataobjects can be viewed in the system.
- The contextified dataobject `myIngressClass` is created in the context of the aggregated component `Installation.default.my-aggregation`.
- the echo server installation imports the `myIngressClass` as `ingressClass` which created the dataobject in its context `Installation.default.server-nl5gk`
- The export of the aggregation `myAggIngressClass` was also successfully created. 
  But as the aggregation's context is the root, its export is also created withtin the root context.


```shell script
k get do
NAME                               CONTEXT                               KEY
2b6qbxj5zrd4keg3rgf5coykfugqisst                                         myAggIngressClass
a5kitry6mccgej3yllwql2kgixe3bnmk   Execution.default.ingress-jjffc
e4yp33ilq4yklzehknh6c5s4677wcuvp   Execution.default.server-nl5gk
erykl7fdudtomre27fbsflpifof6h6op   Installation.default.my-aggregation   myIngressClass
x32pwelcl5sssak3otanbo2lta2ndaat   Installation.default.server-nl5gk     ingressClass
```

### Summary

- A blueprint has been created that includes a ingress-nginx and an echo server.
- With that blueprint is it now possible for others to reuse the aggregated blueprint and deploy the ingress together with the echo server.

### Up next

In the [next tutorial](05-external-jsonschema.md), a external jsonschema is used to describe imports.
